/**
 * @project let-sGo
 * @Author 27
 * @Description //TODO
 * @Date 2021/4/19 21:17 4月
 **/
package main

import "fmt"

/*
new 是一个分配内存的内建函数，但不同于其他语言中同名的new所作的工作，它只是将内存清零，而不是初始化内存。
new(T)为一个类型为T的新项目分配了值为零的存储空间并返回其地址，也就是一个类型为*T的值。
用Go的术语来说，就是它返回了一个指向新分配的类型为T的零值的指针。

make(T, args)函数的目的与new(T)不同。它仅用于创建切片、map和chan（消息管道），并返回类型T（不是*T）的一个被初始化了的（不是零）实例。

这种差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。
例如，切片是一个具有三项内容的描述符，包括指向数据（在一个数组内部）的指针、长度以及容量，在这三项内容被初始化之前，切片值为nil。
对于切片、映射和信道，make初始化了其内部的数据结构并准备了将要使用的值。如：
下面的代码分配了一个整型数组，长度为10，容量为100，并返回前10个数组的切片
make([]int, 10, 100)

*/
func main() {
	// 以下说明new 和 make的不同
	//var p *[]int = new([]int)  // 为切片结构分配内存；*p == nil；很少使用
	//var v []int = make([]int, 10)  // 切片v现在是对一个新的有10个整数的数组的引用

	// 不必要的使问题复杂化：
	var p *[]int = new([]int)
	fmt.Println(p) // 输出： &[]
	*p = make([]int, 10, 10)
	fmt.Println(p)  // 输出： &[0 0 0 0 0 0 0 0 0 0]
	fmt.Println((*p)[2]) //输出： 0

	// 习惯用法
	v := make([]int, 10)
	fmt.Println(v)  // [0 0 0 0 0 0 0 0 0 0]

	s := make(map[string]int)
	delete(s, "h")
	fmt.Println(s["h"])
	/*
	删除 map 不存在的键值对时，不会报错，相当于没有任何作用;获取不存在的减值对时， 返回值类型对应的零值，所以返回 0。
	 */

}

