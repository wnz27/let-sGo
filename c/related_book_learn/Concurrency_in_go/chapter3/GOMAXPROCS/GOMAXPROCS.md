在runtime包中，有一个函数称为GOMAXPROCS。

在我看来这个名称是有误导性的：人们通常认为这个函数与主机上的逻辑处理器的数量有关（而且与它的调度方式有关），
但实际上这个函数控制的OS 线程的数量将承载所谓的"工作队列"。有关这个函数的更多信息以及它的工作原理，在第6章。

在Go语言1.5之前，GOMAXPROCS 总被设置为1， 通常你会在大多数Go语言程序中找到这段代码：
```go
runtime.GOMAXPROCS(runtime.NumCPU())
```
几乎大部分开发人员希望他们的程序正在运行时，可以充分利用机器上的所有CPU核心。
因此，在随后的Go语言版本中，它自动设置为主机上逻辑CPU的数量。

### 那么为什么要调整这个值呢？
大部分时间你都不太想去调节它。Go语言的调度算法在大多数情况下已经足够好了，在增加或减少工作队列和线程数量的情况下，
可能会造成更多的问题，但是仍然有一些情况会改变这个值。

例如，我在一个项目上调试，这个项目有一个测试组件，它被竞争环境困扰。
不管怎么说，这个团队有几个包，有时候测试失败，我们运行测试的主机有四个逻辑CPU，因此在任何一个点上，
我们都有四个goroutine同时执行。
通过增加GOMAXPROCS以超过我们拥有的逻辑CPU数量，我们能够更频繁地触发竞争条件，从而更快的修复它们。

其他人可能通过实验返现，他们的程序在一定数量的工作队列和线程上运行得更好，但我更主张谨慎些。
如果你通过调整这个方法来压缩性能，那么在每次提交之后，当你使用不同的硬件，以及使用不同版本的Go语言时，
一定要这样做。调整这个值会使你的程序更接近它所运行的硬件，但以抽象和长期性能稳定为代价。
