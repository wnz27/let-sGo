<!--
* @UpdateTime : 2021/3/12 23:20
* @Author : 27
* @description: type some description
-->

## 一、
下载go语言：[go语言中文网](https://studygolang.com/dl)

## 二、
终端输入: `go version` 查看版本
`go env` 查看go各种环境配置
换镜像： `go env -w GOPROXY=https://goproxy.cn,direct`
设置go module: `go env -w GO111MODULE=on`

go get 
```
-v：打印出被构建的代码包的名字
-u：已存在相关的代码包，强行更新代码包及其依赖包
```

### 注意
这里我们的on必须是小写的，不是大写ON，也不是1或者true等。
打错的同学就会碰到这个bug: https://github.com/golang/go/issues/34880 
它不会告诉你打错了，但是接下来go env, 甚至其它go run, go install等都不能用了。

出错信息是：
```
root@d952a1d8fe21:/go# go env
go: unknown environment setting GO111MODULE=ON
```
这样解决：
```
root@d952a1d8fe21:/go# export GO111MODULE=on    # 设置环境变量，windows的同学使用SET GO111MODULE=on
root@d952a1d8fe21:/go# go env -w GO111MODULE=on  # 重新向go env写入正确的值
root@d952a1d8fe21:/go# go env   # 验证问题解决
GO111MODULE="on"
GOARCH="amd64"
GOBIN=""
GOCACHE="/root/.cache/go-build"
GOENV="/root/.config/go/env"
GOEXE=""
GOFLAGS=""
GOHOSTARCH="amd64"
```

# 语法
## 数组是值类型
[10]int 和[20]int 是不同的类型
调用func f(arr [10]int)会拷贝数组， 传参值传递
解决这个问题可以用传指针解决
go语言中一般不直接使用数组

## 切片
```
arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s := arr[2:6]
s[0] = 10
// Slice本身没有数据，是对底层array的一个view
// arr的值变为[0, 1, 10, 3, 4, 5, 6, 7]

```
### Slice的扩展
[代码](../code_content/array_iter/array_iter.go)

## Struct
[代码](../code_content/tree/node.go)

## 封装
名字一般使用CamelCase

首字母大写 public
首字母小写 private
针对包来说的

## 包
每个目录一个包
main包包含可执行入口
为结构定义的方法必须放在同一个包内
可以是不同的文件

## 如何扩充系统类型或者别人的类型
定义别名
使用组合

## 内存分配
[make_and_new](../code_content/make_and_new/make_new.go) , 笔记来源--[陈皓酷壳](https://coolshell.cn/articles/8460.html)

###接口相关
[接口与多态 interface_polymorphic](../code_content/go_interface_polymorphic/polymorphic_interface.go)


## 其他练习
[go_prac](../code_content/go_base/go_prac.go)

## 问题
- 为什么Go语言对通道要限制长度而不提供无限长度的通道？
  > 我们知道通道（channel）是在两个goroutine间通信的桥梁。使用goroutine的代码必然有一方提供数据，一方消费数据。
  当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。
  因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在**消费方处理量+通道长度**的范围内，才能正常地处理数据。

## go mod
> go.mod 文件又保存了什么信息呢，实际上 go.mod 文件是启用了 Go modules 的项目所必须的最重要的文件，因为它描述了当前项目（也就是当前模块）的元信息，每一行都以一个动词开头，

目前有以下 5 个动词:
- module：用于定义当前项目的模块路径。
- go：用于设置预期的 Go 版本。
- require：用于设置一个特定的模块版本。
- exclude：用于从使用中排除一个特定的模块版本。
- replace：用于将一个模块版本替换为另外一个模块版本。

> 你可能还会疑惑 indirect 是什么东西，indirect 的意思是传递依赖，也就是非直接依赖。

### 基础使用
- 用 go get 拉取新的依赖
  - 拉取最新的版本(优先择取 tag)：go get golang.org/x/text@latest
  - 拉取 master 分支的最新 commit：go get golang.org/x/text@master
  - 拉取 tag 为 v0.3.2 的 commit：go get golang.org/x/text@v0.3.2
  - 拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2：go get golang.org/x/text@342b2e
- 用 go get -u 更新现有的依赖
- 用 go mod download 下载 go.mod 文件中指明的所有依赖
- 用 go mod tidy 整理现有的依赖
- 用 go mod graph 查看现有的依赖结构
- 用 go mod init 生成 go.mod 文件 (Go 1.13 中唯一一个可以生成 go.mod 文件的子命令)
- 用 go mod edit 编辑 go.mod 文件
- 用 go mod vendor 导出现有的所有依赖 (事实上 Go modules 正在淡化 Vendor 的概念)
- 用 go mod verify 校验一个模块是否被篡改过

这一小节主要是针对 Go modules 的基础使用讲解

注：建议阅读官方文档 [wiki/Modules](https://github.com/golang/go/wiki/Modules)

#### go.sum 
> 文件详细罗列了当前项目直接或间接依赖的所有模块版本，
并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。


