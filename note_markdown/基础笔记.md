<!--
* @UpdateTime : 2021/3/12 23:20
* @Author : 27
* @description: type some description
-->

## 一、
下载go语言：[go语言中文网](https://studygolang.com/dl)

## 二、
终端输入: `go version` 查看版本
`go env` 查看go各种环境配置
换镜像： `go env -w GOPROXY=https://goproxy.cn,direct`
设置go module: `go env -w GO111MODULE=on`

go get 
```
-v：打印出被构建的代码包的名字
-u：已存在相关的代码包，强行更新代码包及其依赖包
```

### 注意
这里我们的on必须是小写的，不是大写ON，也不是1或者true等。
打错的同学就会碰到这个bug: https://github.com/golang/go/issues/34880 
它不会告诉你打错了，但是接下来go env, 甚至其它go run, go install等都不能用了。

出错信息是：
```
root@d952a1d8fe21:/go# go env
go: unknown environment setting GO111MODULE=ON
```
这样解决：
```
root@d952a1d8fe21:/go# export GO111MODULE=on    # 设置环境变量，windows的同学使用SET GO111MODULE=on
root@d952a1d8fe21:/go# go env -w GO111MODULE=on  # 重新向go env写入正确的值
root@d952a1d8fe21:/go# go env   # 验证问题解决
GO111MODULE="on"
GOARCH="amd64"
GOBIN=""
GOCACHE="/root/.cache/go-build"
GOENV="/root/.config/go/env"
GOEXE=""
GOFLAGS=""
GOHOSTARCH="amd64"
```

# 语法
## 数组是值类型
[10]int 和[20]int 是不同的类型
调用func f(arr [10]int)会拷贝数组， 传参值传递
解决这个问题可以用传指针解决
go语言中一般不直接使用数组

## 切片
```
arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s := arr[2:6]
s[0] = 10
// Slice本身没有数据，是对底层array的一个view
// arr的值变为[0, 1, 10, 3, 4, 5, 6, 7]

```
### Slice的扩展
[代码](../code_content/array_iter/array_iter.go)

## Struct
[代码](../code_content/tree/node.go)

## 封装
名字一般使用CamelCase

首字母大写 public
首字母小写 private
针对包来说的

### 包
每个目录一个包
main包包含可执行入口
为结构定义的方法必须放在同一个包内
可以是不同的文件

### 如何扩充系统类型或者别人的类型
定义别名
使用组合

### 内存分配
[make_and_new](../code_content/make_and_new/make_new.go) , 笔记来源--[陈皓酷壳](https://coolshell.cn/articles/8460.html)

### 接口相关
[接口与多态 interface_polymorphic](../code_content/go_interface_polymorphic/polymorphic_interface.go)


### 其他练习
[go_prac](../code_content/go_base/go_prac.go)

###问题
- 为什么Go语言对通道要限制长度而不提供无限长度的通道？
  > 我们知道通道（channel）是在两个goroutine间通信的桥梁。使用goroutine的代码必然有一方提供数据，一方消费数据。
  当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。
  因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在**消费方处理量+通道长度**的范围内，才能正常地处理数据。

