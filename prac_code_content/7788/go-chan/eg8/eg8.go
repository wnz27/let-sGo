/*
* Author:  a27
* Version: 1.0.0
* Date:    2021/5/1 8:04 下午
* Description:
 */
package main

import "fmt"

/*
关闭通道后继续使用通道通道是一个引用对象，和map类似。
map在没有任何外部引用时，Go程序在运行时（runtime）会自动对内存进行垃圾回收（Garbage Collection,GC）。
类似的，通道也可以被垃圾回收，但是通道也可以被主动关闭。
 */

// 给被关闭通道发送数据将会触发panic
// panic: send on closed channel


func main() {
	// 从已关闭的通道接收数据时将不会发生阻塞
	// 从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。
	// 创建一个整型，带两个缓冲的通道
	ch := make(chan int, 2)

	// 给通道放入两个数据
	ch <- 2
	ch <- 3

	// 关闭缓冲通道
	close(ch)

	// 遍历缓冲所有数据，且多遍历一个
	for i := 0; i < cap(ch) + 1; i++ {
		/*
		cap()函数可以获取一个对象的容量，这里获取的是带缓冲通道的容量，也就是这个通道在make时的大小。
		虽然此时这个通道的元素个数和容量都是相同的，但是cap取出的并不是元素个数。
		这里多遍历一个元素，故意造成这个通道的超界访问。
		 */
		// 从通道取出数据
		v, ok := <-ch
		// 打印取出数据的状态
		fmt.Println(v, ok)
	}
}
