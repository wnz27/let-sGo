# 复制请求
对于某些应用来说，尽可能快地接收响应是重中之重。 例如，程序正在处理用户的HTTP 请求，或者检索一个数据块。
在这些情况下，你可以进行权衡：
你可以将请求分发到多个处理程序（无论是 goroutine， 进程，还是服务器），其中一个将比其他处理程序返回更快，
你可以立即返回结果。
缺点是为了维持多个实例的运行，你将不得不消耗更多的资源。

如果这种复制是在内存中进行的，消耗则没有那么大，但是如果多个处理程序需要多个进程，
服务器甚至是数据中心，那可能会变得相当昂贵。所以你需要决定这么做是否值得。

我们来看看如何在单个进程中制造复制请求。我们将使用多个 goroutine 作为处理程序，并且 goroutine 将
随机休眠一段时间以模拟不同的负载，休眠时间在1 到 6 纳秒之间。这将使我们处理程序在不同的时间
返回结果，并且我们可以看到复制请求如何更快的返回结果。

下面是一个在 10 个处理程序上复制模拟请求的例子：
```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func main() {
	doWork := func(
		done <-chan interface{},
		id int,
		wg *sync.WaitGroup,
		result chan<- int,
	) {
		started := time.Now()
		defer wg.Done()

		// 模拟随机负载
		simulatedLoadTime := time.Duration(1 + rand.Intn(5)) * time.Second
		select {
		case <- done:
		case <-time.After(simulatedLoadTime):
		}
		select {
		case <-done:
		case result <- id:
		}

		took := time.Since(started)
		// 显示处理程序需要多长时间
		if took < simulatedLoadTime {
			took = simulatedLoadTime
		}
		fmt.Printf("%v took %v\n", id, took)
	}

	done := make(chan interface{})
	result := make(chan int)

	var wg sync.WaitGroup
	wg.Add(10)

	for i := 0; i < 10; i ++ {
		// 我们启动10个处理程序来处理请求。
		go doWork(done, i, &wg, result)
	}

	// 获得处理程序组的第一个返回值
	firstReturned := <-result
	// 我们取消其余的处理程序，以保证他们不会继续做多余的工作。
	close(done)
	wg.Wait()

	fmt.Printf("Received an answer from #%v\n", firstReturned)
}
```
运行得到：
```shell
2 took 4s
1 took 1.003802389s
6 took 1.003611581s
9 took 3s
8 took 2s
5 took 2s
0 took 2s
4 took 3s
3 took 1.003835015s
7 took 5s
Received an answer from #6
```
从上面的日志看出，这是第 6 个处理程序返回的最快。在输出中我们将显示每个
处理程序所花费的时间，以便你可以了解这样处理可以节省多少时间。
想象一下，如果你只运行一个处理程序，而恰巧是第 5 个处理程序，那请求将不得不等待 5s 
才能被处理，而不是刚刚超过 1 s 就能被处理完。

有一点需要注意，所有的处理程序都应该是尽可能等价的，有相同的机会处理请求。
或者说，你不能从一个无法处理请求的程序那获得最快的响应。就像我说的，每个
处理程序都应该有相同的资源。

同一问题的不同特征是大致相似的。你的处理程序越相似，那出现意外的概率就越小。
在增加副本时，你应该尽可能复制：你应该只将这样的请求复制到具有不同运行时条件的处理程序。
不同的进程，机器，存储路径以及不同的数据源。

虽然建立和维护这样一套系统有很大的代价，但如果你追求的是响应速度，那这是一种非常有价值的架构。
另外这种方式天然的提供了容错和可扩展性。


