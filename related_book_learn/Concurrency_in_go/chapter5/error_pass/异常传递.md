# 异常传递
编写并发代码，特别是在分布式系统中，你的系统中非常容易出现一些奇怪问题，
并且难以理解为什么会发生这种情况。为了将你自己、你的团队、你的用户从众多的
痛苦中拯救出来，你需要仔细考虑异常（error）是如何通过分布式系统传递的，
以及问题最终将如何呈现给使用者。
在第4章"异常处理"中，我们研究了如何将 goroutine 中的异常传递出来，但
并未过多探讨这些异常应当是什么样的，或者异常应当如何经过一个庞大而复杂的
系统传递出来。以下是用于处理并发系统中异常的一个示意框架，让我们用这个
框架来对异常传递的哲学进行一些研究。

许多开发人员有个误解，认为在系统流程中异常的传递并不是那么重要。他们通常会
谨慎的考虑数据会如何经过系统，但是却轻易地容忍异常，未经过思考就将异常从栈中
抛出，最终导致异常直接展示在了用户面前。

Go语言试图纠正这种不良习惯，强制开发人员处理调用栈上的每个关键点的异常，但是
在系统控制流中对异常视而不见，仍然是一种常见的行为。
其实只需要一点计划和非常小的代价，你就可以将异常控制在系统范围内，优化你的用户体验。

首先让我们来明确异常是什么，什么时候发生，提供了哪些好处。

出现异常表示着你的系统进入了一个无法满足用户操作的状态，这个操作可能是显式的，也可能是隐式的。
这时系统需要传达几个关键的信息：
- ***发生了什么***
  > 这部分异常信息包含了对异常事件的描述。例如："磁盘已满"， "连接重置"，"证书过期"。这些信息可能是被一些
  代码隐式的表达出来的，你可以用一些上下文来修饰这些信息来帮助用户理解发生了什么问题。
- ***发生在什么时间、什么位置***
  > 异常应当总是包含完整的栈轨迹信息，从调用的启动方式开始，以异常的实例结尾。
  **栈轨迹信息不应该包含在异常消息中（这一点尤为重要）**，但当需要处理栈中的异常时应该很容易被找到。
  
  >  更进一步讲，异常应当包含有关其内部运行的上下文信息。例如，在分布式系统中，异常应该有一些字段用来
  识别发生异常的机器。发生异常后，这些信息会对你诊断系统故障原因非常有价值。
  
  > 此外，异常还应包含对应机器上的时间，并且最好是 UTC 时间。

- ***对用户友好的提示***
  > 应当对展现给用户的异常信息进行自定义，以适应你的系统和用户。这些信息应该只包含前两点的概述以及相关信息。
  对用户友好的信息时从用户的角度考虑，给出一些信息，说明这些问题是否是暂时的，并且最好是一行以内的文本。
  
- ***告诉用户如何获得更多的信息***
  > 在某些情况下，用户希望知道当异常发生时，具体发生了哪些故障。展现给用户的异常信息应当提供一个ID，利用这个
  ID 可以查询到对应的详细日志。这个详细日志应显示异常的完整信息：
  发生异常的时间（而不是异常记录的时间），异常创建时完整的堆栈调用。包含一个堆栈轨迹的 hash 也有助于聚合这些
  异常，就像 bug 追踪器那样跟踪问题。
  
默认状态下，如果你不介入，异常信息不会包含上述所有的信息。因此，你应当保持这样一种观念，任何展现给用户的异常信息
如果没包含这些信息，不是出错了就是有bug。这引出了一个可以用来处理异常的通用模型。所有的异常都几乎能归为以下两种
分类之一：
- Bug
- 已知信息（例如：网络连接断开，磁盘写入失败等）。

Bug 是一些你未在你的系统中定义的异常，或者一些"原生"的异常，就是那些极少遇到的情况。有时这是有意为之的，
在你系统最初的几次迭代中，一些异常展现给用户是可以接受的。还有些时候这是意外发生的。总之，如果你同意我所
提出的方法，即"原生"异常总是bug。在确定如何传播异常时，在系统随着时间的推移如何增长以及最终向用户展示什么时，
这种区别被证明是非常有用的。

想象一个多模块的大型系统：
```
命令行组件  --》  中层组件   --》   底层组件
```  
我们假设在 "底层组件" 中产生了一个结构良好的异常，他正在等待上传到栈中。在"底层组件"的语境中，这个异常的
结构可能是良好的，但是在我们的系统中，它可能并非如此。让我们以每个组件的边界为例，所有传入的异常信息都必须使用
我们的代码重新格式化。例如，我们在 "中层组件" 调用 "底层组件" 中可能会出错函数时，我们可以这样写：
```go
// PostReport 伪码
func PostReport(id string) error {
	result, err := lowleverl.DoWork()
	if err != nil {
		// 在这里，我们检查一下接收到的异常信息，以确保它的结构是良好的。
		// 如果不是，我们就简单地将异常对到栈上，以显示出这个bug。
		if _, ok := err.(lowlevel.Error); ok {
			// 我们使用一个假设的函数将传入的异常和模块相关的信息封装起来，并赋予它
			// 一个新的类型。请注意，封装异常可能会隐藏一些底层细节，这些细节对于用户
			// 来说可能并不重要。
			err = WrapErr(err, "cannot post report with id %q", id)
		}
		return err
	}
}
```
当异常被最初实例化时，异常信息中包含了底层细节，这些细节与异常产生的根源（例如，goroutine，机器，栈轨迹等）息息相关。

