# 异常传递
编写并发代码，特别是在分布式系统中，你的系统中非常容易出现一些奇怪问题，
并且难以理解为什么会发生这种情况。为了将你自己、你的团队、你的用户从众多的
痛苦中拯救出来，你需要仔细考虑异常（error）是如何通过分布式系统传递的，
以及问题最终将如何呈现给使用者。
在第4章"异常处理"中，我们研究了如何将 goroutine 中的异常传递出来，但
并未过多探讨这些异常应当是什么样的，或者异常应当如何经过一个庞大而复杂的
系统传递出来。以下是用于处理并发系统中异常的一个示意框架，让我们用这个
框架来对异常传递的哲学进行一些研究。

许多开发人员有个误解，认为在系统流程中异常的传递并不是那么重要。他们通常会
谨慎的考虑数据会如何经过系统，但是却轻易地容忍异常，未经过思考就将异常从栈中
抛出，最终导致异常直接展示在了用户面前。

Go语言试图纠正这种不良习惯，强制开发人员处理调用栈上的每个关键点的异常，但是
在系统控制流中对异常视而不见，仍然是一种常见的行为。
其实只需要一点计划和非常小的代价，你就可以将异常控制在系统范围内，优化你的用户体验。

首先让我们来明确异常是什么，什么时候发生，提供了哪些好处。

出现异常表示着你的系统进入了一个无法满足用户操作的状态，这个操作可能是显式的，也可能是隐式的。
这时系统需要传达几个关键的信息：
- ***发生了什么***
  > 这部分异常信息包含了对异常事件的描述。例如："磁盘已满"， "连接重置"，"证书过期"。这些信息可能是被一些
  代码隐式的表达出来的，你可以用一些上下文来修饰这些信息来帮助用户理解发生了什么问题。
- ***发生在什么时间、什么位置***
  > 异常应当总是包含完整的栈轨迹信息，从调用的启动方式开始，以异常的实例结尾。
  **栈轨迹信息不应该包含在异常消息中（这一点尤为重要）**，但当需要处理栈中的异常时应该很容易被找到。
  
  >  更进一步讲，异常应当包含有关其内部运行的上下文信息。例如，在分布式系统中，异常应该有一些字段用来
  识别发生异常的机器。发生异常后，这些信息会对你诊断系统故障原因非常有价值。
  
  > 此外，异常还应包含对应机器上的时间，并且最好是 UTC 时间。

- ***对用户友好的提示***
  > 应当对展现给用户的异常信息进行自定义，以适应你的系统和用户。这些信息应该只包含前两点的概述以及相关信息。
  对用户友好的信息时从用户的角度考虑，给出一些信息，说明这些问题是否是暂时的，并且最好是一行以内的文本。
  
- ***告诉用户如何获得更多的信息***
  > 在某些情况下，用户希望知道当异常发生时，具体发生了哪些故障。展现给用户的异常信息应当提供一个ID，利用这个
  ID 可以查询到对应的详细日志。这个详细日志应显示异常的完整信息：
  发生异常的时间（而不是异常记录的时间），异常创建时完整的堆栈调用。包含一个堆栈轨迹的 hash 也有助于聚合这些
  异常，就像 bug 追踪器那样跟踪问题。
  
默认状态下，如果你不介入，异常信息不会包含上述所有的信息。因此，你应当保持这样一种观念，任何展现给用户的异常信息
如果没包含这些信息，不是出错了就是有bug。这引出了一个可以用来处理异常的通用模型。所有的异常都几乎能归为以下两种
分类之一：
- Bug
- 已知信息（例如：网络连接断开，磁盘写入失败等）。

Bug 是一些你未在你的系统中定义的异常，或者一些"原生"的异常，就是那些极少遇到的情况。有时这是有意为之的，
在你系统最初的几次迭代中，一些异常展现给用户是可以接受的。还有些时候这是意外发生的。总之，如果你同意我所
提出的方法，即"原生"异常总是bug。在确定如何传播异常时，在系统随着时间的推移如何增长以及最终向用户展示什么时，
这种区别被证明是非常有用的。

想象一个多模块的大型系统：
```
命令行组件  --》  中层组件   --》   底层组件
```  
我们假设在 "底层组件" 中产生了一个结构良好的异常，他正在等待上传到栈中。在"底层组件"的语境中，这个异常的
结构可能是良好的，但是在我们的系统中，它可能并非如此。让我们以每个组件的边界为例，所有传入的异常信息都必须使用
我们的代码重新格式化。例如，我们在 "中层组件" 调用 "底层组件" 中可能会出错函数时，我们可以这样写：
```go
// PostReport 伪码
func PostReport(id string) error {
	result, err := lowleverl.DoWork()
	if err != nil {
		// 在这里，我们检查一下接收到的异常信息，以确保它的结构是良好的。
		// 如果不是，我们就简单地将异常对到栈上，以显示出这个bug。
		if _, ok := err.(lowlevel.Error); ok {
			// 我们使用一个假设的函数将传入的异常和模块相关的信息封装起来，并赋予它
			// 一个新的类型。请注意，封装异常可能会隐藏一些底层细节，这些细节对于用户
			// 来说可能并不重要。
			err = WrapErr(err, "cannot post report with id %q", id)
		}
		return err
	}
}
```
当异常被最初实例化时，异常信息中包含了底层细节，这些细节与异常产生的根源（例如，goroutine，机器，栈轨迹等）息息相关。
不过我们的体系规定了，我们应当在模块的边界处将这些底层异常转换成我们这一层模块的异常结构，并将底层细节改写成与我们模块
相关的信息。现在，如果出现了一些异常，并且并非我们模块的异常结构，便可以认为是格式异常，或者是一个bug。请注意，
**只在必要时**才用这种方式封装异常，比如你自己的模块边界（公共函数/方法）或者你的代码要添加有意义的上下文。
这可以防止在大量的代码中重新封装异常信息。

采用这一机制，可以使我们的系统有机的增长。我们可以确定的是，传入的异常是完整的。反过来说，我们可以保证我们正在考虑异常如何
传出我们的模块。异常的正确性成为我们系统的一个关键属性。我们也从一开始就尽可能完美、明确地处理不规范的异常，这样我们构建出
一个处理异常的框架，随着时间的推移不断的纠正异常。再通过呈现给用户的类型划分，可以更清晰地划分异常。

正如我们上面说的，所有的异常都应该尽可能的记录下来，但是，当向用户显示异常时，bug和已知异常还是有一定区别的。
当我们面向用户部分的代码收到一个格式良好的异常信息时，我们知道在代码的各个层面上，我们都小心处理了异常，
我们可以将其记录下来并打印出来供用户查看。确保异常类型的准确有效是非常重要的。

当不规范的异常或bug传递给用户时，我们也应该记录异常，但是应该向用户显示一条友好的消息，指发出了以外的事情。
如果我们在系统中支持自动的异常报告，则应该将这些问题报告为bug。如果我们不这样做，我们应该建议用户提交一个bug反馈。
请注意，不规范的异常实际上也可能包含有用的信息，但我们不能保证这一点，我们唯一能确认的是异常没有经过我们格式化。
因此我们应该直截了当地展示一段人类可解读的信息，来展示刚刚发生的事情。

请记住，在这两种情况下，如果出现格式不规范的异常，我们将在消息中包含一个日志ID，以便用户在需要更多信息时可以查询到
相关的内容。因此，如果bug确实包含了有用的信息，有需要的用户仍然有可追踪的线索。

我们来看一个完整的例子。这个例子并不是非常健壮（例如，异常类型可能很简单），调用顺序也是线性的，
这使我们只需要在模块边界处封装异常。而且，在一本书中很难用不同的包来表示函数，所以我们会假定这些函数是存在的。

首先，我们来创建一个异常类型，它包含了一个格式良好的异常应有的内容：
```go

```
