# 超时和取消 
在并发代码运行时，超时（Timeouts） 和 取消 （Cancellation）会频繁出现。
在本节中我们将会看到，超时的处理对于创建一个易于理解的系统是至关重要的，
进程被取消是其发生超时的自然反映。我们还将讨论一个并发进程可能被取消的原因。

那么我们为什么希望我们的并发程序支持超时呢？这里有几个原因：
- ***系统饱和度***
- ***陈旧的数据***
- ***防止防止死锁***

现在我们已经掌握应当何时使用超时了，让我们把注意力转向取消，以及如何建立一个并发处理来优雅地处理取消。
并发进程可能被取消的原因有很多：
- ***超时***
- ***用户干预***
- ***父进程取消***
- ***复制请求***

也可能有其他的原因。然而，"为何"这个问题并不像"如何"这样的问题那么困难或有趣。
在第4章中，我们讨论了两种取消并发进程的方法：`channel done` 和 `context.Context` 类型。
这是相对容易的一部分，在这里我们想要探索更复杂的问题：
- **当一个并发进程被取消时，对于正在执行的算法及其下游消费者意味着什么？**
- **在编写可随时终止的并发代码时，需要考虑哪些事项？**


