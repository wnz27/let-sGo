# 超时和取消 
在并发代码运行时，超时（Timeouts） 和 取消 （Cancellation）会频繁出现。
在本节中我们将会看到，超时的处理对于创建一个易于理解的系统是至关重要的，
进程被取消是其发生超时的自然反映。我们还将讨论一个并发进程可能被取消的原因。

那么我们为什么希望我们的并发程序支持超时呢？这里有几个原因：
- ***系统饱和度***
  > 正如我们在第4章 "队列" 中所讨论的，如果我们的系统已经饱和（即它的处理请求的能力刚好足够处理），
  > 我们可能希望超出的请求返回超时，而不是花很长时间等待响应。你采取的应对方式取决于你的问题空间，
  > 下面是一些关于何时应当超时的一般性指导：
  - 请求在超时时不太可能重复。
  - 没有资源来存储请求（例如，内存队列的内存，持久队列的磁盘空间）。
  - 如果对系统的响应 或 请求发送数据有时效性的要求（接下来会讨论）。如果一个请求可能会重复，
    超时会额外增加一个请求和超时的消耗。如果开销超过我们系统的容量，这可能会导致系统宕机。
    不管怎样，如果我们缺少将请求存储在队列中所需的系统资源，那也是没有意义的。
    即便我们符合这两个指导方针，只要我们能即使处理，让请求进入排队中意义也不大。
    这给我们带来了下一个支持超时的理由。
- ***陈旧的数据***
  > 数据通常有一个窗口期，一般是在这个窗口必须先处理更多的相关数据，或者处理数据的需求已经过期。
  > 如果一个并发进程处理数据需要的时间比这个窗口期更长，我们会想返回超时并取消并发进程。例如，
  > 如果我们的并发进程在长时间的等待之后响应请求，则在队列中的请求或其数据可能已经过时。
  
  > 如果事先知道这个窗口时间，那么将context.WithDeadline 或 context.WithTimeout 创建的 
  > context.Context 传递给我们的并发进程是有意义的。
  
  > 如果事先不知道窗口时间，我们希望并发进程的父节点能够在请求不再需要时取消并发进程。 
  > context.WithCancel 是达到这个目的的最佳选择。
- ***防止防止死锁***
  > 在大型系统中，尤其是分布式系统中，有时难以理解数据流动的方式，或者可能出现的异常。
  > 为了保证系统不会发生死锁，建议在所有并发操作中增加超时处理。
  > 超时时间不一定要接近执行并发操作所需的实际时间。不过超时的目的只是为了防止死锁，所以
  > 需要它足够短，使死锁的系统在合理的时间内解除阻塞即可。
  
  > 以上内容使我们知道了，尝试通过设置超时可以将一个死锁系统转变为一个活锁系统。
  > 不过，在大型系统中，由于存在更多灵活的组件，在系统死锁后，你的系统更可能会遇到时序配置不同步的情况。
  > 因此，最好是在允许的时间内尽可能修复活锁，好过发生死锁后只有通过重新启动才能恢复系统。
  
  > 这不是如何正确构建系统的建议，而是关于如何建立一个对时间问题有容错能力的系统，这些错误在开发和
  > 测试过程中可能不容易遇到。我建议你将超时设置在适当的位置，但是目标应该是在没有触发超时的情况下
  > 处理完所有的请求。

现在我们已经掌握应当何时使用超时了，让我们把注意力转向取消，以及如何建立一个并发处理来优雅地处理取消。
并发进程可能被取消的原因有很多：
- ***超时***
- ***用户干预***
- ***父进程取消***
- ***复制请求***

也可能有其他的原因。然而，"为何"这个问题并不像"如何"这样的问题那么困难或有趣。
在第4章中，我们讨论了两种取消并发进程的方法：`channel done` 和 `context.Context` 类型。
这是相对容易的一部分，在这里我们想要探索更复杂的问题：
- **当一个并发进程被取消时，对于正在执行的算法及其下游消费者意味着什么？**
- **在编写可随时终止的并发代码时，需要考虑哪些事项？**


